---
phase: 01-foundation-jmap-client
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/jmap/client.ts
  - src/types/jmap.ts
  - src/index.ts
  - tests/jmap/client.test.ts
autonomous: true

must_haves:
  truths:
    - "JMAP client fetches session and extracts apiUrl, accountId, capabilities"
    - "JMAP client sends batched requests with multiple methodCalls in single HTTP request"
    - "All fetch calls have configurable timeout using AbortSignal.timeout()"
    - "JMAP errors at request level (HTTP), method level, and record level are handled distinctly"
    - "Client tracks state strings from responses for incremental operations"
    - "Connection to jmap.linagora.com can be validated at startup"
  artifacts:
    - path: "src/jmap/client.ts"
      provides: "JMAP client with session, batching, timeout, state tracking"
      exports: ["JMAPClient", "JMAPSession"]
      min_lines: 150
    - path: "src/types/jmap.ts"
      provides: "TypeScript types for JMAP protocol"
      exports: ["JMAPRequest", "JMAPResponse", "JMAPMethodCall", "JMAPMethodResponse"]
    - path: "tests/jmap/client.test.ts"
      provides: "Unit tests for JMAP client"
      contains: "describe('JMAPClient'"
  key_links:
    - from: "src/index.ts"
      to: "src/jmap/client.ts"
      via: "JMAPClient import and initialization"
      pattern: "new JMAPClient"
    - from: "src/jmap/client.ts"
      to: "src/config/schema.ts"
      via: "Config type dependency"
      pattern: "import.*Config.*from.*config/schema"
    - from: "src/jmap/client.ts"
      to: "src/errors.ts"
      via: "JMAPError for error handling"
      pattern: "import.*JMAPError.*from.*errors"
---

<objective>
Build a complete JMAP client with session management, request batching, configurable timeouts, multi-level error handling, and state tracking.

Purpose: The JMAP client is the core integration layer between MCP tools and the email server. It must handle authentication, batching for efficiency, timeouts for reliability, and state tracking for incremental sync.

Output: A production-ready JMAPClient class that can be used by email and mailbox services in later phases.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-jmap-client/01-RESEARCH.md
@.planning/phases/01-foundation-jmap-client/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JMAP types and client core</name>
  <files>src/types/jmap.ts, src/jmap/client.ts</files>
  <action>
Create src/types/jmap.ts with TypeScript types:
- JMAPCapabilities: Record&lt;string, unknown&gt;
- JMAPAccount: { name: string; isPersonal: boolean; accountCapabilities: JMAPCapabilities }
- JMAPSessionResponse: { capabilities: JMAPCapabilities; accounts: Record&lt;string, JMAPAccount&gt;; primaryAccounts: Record&lt;string, string&gt;; apiUrl: string; state: string }
- JMAPMethodCall: [methodName: string, args: Record&lt;string, unknown&gt;, callId: string]
- JMAPMethodResponse: [methodName: string, response: Record&lt;string, unknown&gt;, callId: string]
- JMAPRequest: { using: string[]; methodCalls: JMAPMethodCall[] }
- JMAPResponse: { methodResponses: JMAPMethodResponse[]; sessionState?: string }
- JMAPErrorResponse: { type: string; description?: string }

Create src/jmap/client.ts with JMAPClient class:
- Constructor takes Config and Logger
- Private fields: session (JMAPSession | null), config, logger, stateTracker (Map&lt;string, string&gt;)
- JMAPSession interface: { apiUrl: string; accountId: string; capabilities: JMAPCapabilities; state: string }

Implement getAuthHeaders(): Record&lt;string, string&gt;:
- For basic: Base64 encode username:password, return Authorization: Basic {token}
- For bearer: return Authorization: Bearer {token}
- For oidc: return Authorization: Bearer {token} (same as bearer for now, OIDC flow in Phase 2)
- Always include Content-Type: application/json

Implement fetchSession(): Promise&lt;JMAPSession&gt;:
- GET request to config.JMAP_SESSION_URL
- Use AbortSignal.timeout(5000) for session fetch (quick check)
- Parse response as JMAPSessionResponse
- Extract accountId from primaryAccounts['urn:ietf:params:jmap:mail']
- If no mail account found, throw JMAPError with type 'noMailAccount'
- Store session, log success with accountId and apiUrl
- Return session

Implement getSession(): JMAPSession:
- Throw JMAPError if session not initialized
- Return stored session

Follow patterns from 01-RESEARCH.md Pattern 3.
  </action>
  <verify>
npm run build succeeds with no TypeScript errors.
Types are exported correctly from src/types/jmap.ts.
JMAPClient can be instantiated with mock config and logger.
  </verify>
  <done>
JMAPClient class exists with session fetch, auth header generation, and basic structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement request batching, timeout, and error handling</name>
  <files>src/jmap/client.ts, src/errors.ts</files>
  <action>
Add to src/jmap/client.ts:

Implement request(methodCalls: JMAPMethodCall[], using?: string[]): Promise&lt;JMAPResponse&gt;:
- If session not initialized, throw JMAPError
- Build JMAPRequest with:
  - using: provided array or default ['urn:ietf:params:jmap:core', 'urn:ietf:params:jmap:mail']
  - methodCalls: provided array (supports batching multiple calls)
- POST to session.apiUrl with:
  - Headers from getAuthHeaders()
  - Body: JSON.stringify(request)
  - signal: AbortSignal.timeout(config.JMAP_REQUEST_TIMEOUT) (configurable, default 30000ms)
- Handle response:
  - If !response.ok: throw JMAPError with HTTP status info
  - Parse JSON as JMAPResponse
  - If sessionState changed, log warning (session refresh needed in Phase 2)
  - Return response

Implement parseMethodResponse(response: JMAPMethodResponse): { success: boolean; data?: unknown; error?: JMAPErrorResponse }:
- If methodName starts with 'error', extract error details
- Handle common JMAP error types:
  - stateMismatch: state is stale, need to refetch
  - cannotCalculateChanges: state too old
  - notFound: record doesn't exist
  - forbidden: no permission
- Return structured result for caller to handle

Update src/errors.ts to enhance JMAPError:
- Add static factory methods:
  - JMAPError.httpError(status: number, statusText: string): JMAPError
  - JMAPError.methodError(type: string, description?: string): JMAPError
  - JMAPError.timeout(operation: string): JMAPError
- Each factory provides appropriate type and fix message

Handle AbortError/TimeoutError in request():
- Catch error.name === 'TimeoutError' or 'AbortError'
- Throw JMAPError.timeout('JMAP request')

Follow patterns from 01-RESEARCH.md Pattern 4 and Pattern 6.
  </action>
  <verify>
npm run build succeeds.
Create unit test mocking fetch to verify:
1. Batched request sends multiple methodCalls in single HTTP request
2. Timeout triggers after configured duration
3. HTTP errors create JMAPError with correct type
4. Method-level errors are parsed correctly
  </verify>
  <done>
Client supports batched requests with configurable timeout and multi-level error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement state tracking and integrate with entry point</name>
  <files>src/jmap/client.ts, src/index.ts, tests/jmap/client.test.ts</files>
  <action>
Add state tracking to src/jmap/client.ts:

Implement updateState(type: string, state: string): void:
- Store state in stateTracker Map with key being the object type (e.g., 'Email', 'Mailbox')
- Log debug message: { type, state }, 'State updated'

Implement getState(type: string): string | undefined:
- Return state from stateTracker Map

Implement clearState(type?: string): void:
- If type provided, delete that key from stateTracker
- If no type, clear entire Map

In request() method:
- After successful response, check each methodResponse for 'state' or 'newState' field
- Extract object type from method name (e.g., 'Email/get' -> 'Email')
- Call updateState() with type and state value

Update src/index.ts to use JMAPClient:
- Import JMAPClient from './jmap/client.js'
- After createLogger(), create JMAPClient instance
- Call await client.fetchSession()
- Log: { accountId: session.accountId }, 'JMAP client ready'
- Add placeholder comment: // MCP server initialization will be added in Phase 3

Create tests/jmap/client.test.ts:
- Use vitest-fetch-mock to mock fetch
- Test fetchSession():
  - Mock successful session response with primaryAccounts
  - Verify session extracted correctly
  - Mock missing mail account, verify JMAPError thrown
- Test request():
  - Mock batched request, verify single HTTP call made
  - Mock timeout, verify JMAPError.timeout thrown
  - Mock method error response, verify parsed correctly
- Test state tracking:
  - Make request with state in response
  - Verify getState() returns correct value
  - Verify clearState() works

Follow patterns from 01-RESEARCH.md Pattern 5.
  </action>
  <verify>
npm run build succeeds.
npm run test passes all tests.
Manual test with real credentials:
```bash
export JMAP_SESSION_URL="https://jmap.linagora.com/jmap/session"
export JMAP_USERNAME="your-email@linagora.com"
export JMAP_PASSWORD="your-password"
node build/index.js
# Should show: "JMAP client ready" with accountId
```
  </verify>
  <done>
Client tracks state strings from responses.
Entry point initializes and validates JMAP connection.
All unit tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build and test:**
   ```bash
   npm run build
   # No TypeScript errors
   npm run test
   # All tests pass
   ```

2. **Type exports verification:**
   ```bash
   grep -E "^export" build/types/jmap.js build/jmap/client.js
   # Should show JMAPClient, JMAPSession, type exports
   ```

3. **Integration test with mock server (unit tests):**
   - Session fetch extracts apiUrl, accountId, capabilities
   - Batched request sends multiple methodCalls
   - Timeout fires after configured duration
   - HTTP errors, method errors, record errors handled distinctly
   - State tracked per object type

4. **Live connection test (if credentials available):**
   ```bash
   export JMAP_SESSION_URL="https://jmap.linagora.com/jmap/session"
   export JMAP_USERNAME="test@linagora.com"
   export JMAP_PASSWORD="testpass"
   timeout 10 node build/index.js 2>&1
   # Should show startup log, session fetch, "JMAP client ready"
   # Or auth error if credentials invalid (expected for test values)
   ```
</verification>

<success_criteria>
- JMAPClient.fetchSession() retrieves session with apiUrl, accountId, capabilities
- JMAPClient.request() supports multiple methodCalls in single request (batching)
- All fetch calls use AbortSignal.timeout() with configurable duration
- HTTP errors (4xx/5xx) throw JMAPError with type and fix message
- Method-level errors (stateMismatch, notFound, etc.) are parsed and returned
- State strings from responses are tracked per object type
- Entry point validates JMAP connection at startup
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-jmap-client/01-02-SUMMARY.md`
</output>
