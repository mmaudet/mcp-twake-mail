---
phase: 03-core-read-operations
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - src/mcp/server.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "MCP server initializes with name 'mcp-twake-mail' and version"
    - "Server connects via stdio transport"
    - "JMAP connection is validated at startup before accepting requests"
    - "Startup failure exits with non-zero code and logs error to stderr"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "MCP server initialization and startup"
      exports: ["createMCPServer", "startServer"]
    - path: "src/index.ts"
      provides: "Main entry point"
      contains: "startServer"
  key_links:
    - from: "src/mcp/server.ts"
      to: "src/jmap/client.ts"
      via: "import JMAPClient"
      pattern: "import.*JMAPClient.*from"
    - from: "src/mcp/server.ts"
      to: "@modelcontextprotocol/sdk"
      via: "McpServer import"
      pattern: "import.*McpServer.*from.*@modelcontextprotocol"
    - from: "src/index.ts"
      to: "src/mcp/server.ts"
      via: "startServer import"
      pattern: "import.*startServer.*from.*mcp/server"
---

<objective>
Create the MCP server foundation with JMAP validation at startup.

Purpose: The MCP server is the entry point for AI assistants. It must validate JMAP connectivity before accepting tool requests (MCP-04), and use stdio transport (MCP-03).

Output: Working MCP server that initializes, validates JMAP, and is ready for tool registration.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-read-operations/03-RESEARCH.md

# Existing codebase
@src/jmap/client.ts
@src/config/schema.ts
@src/config/logger.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP Server Module</name>
  <files>src/mcp/server.ts</files>
  <action>
Create src/mcp/server.ts with:

1. Import McpServer from '@modelcontextprotocol/sdk/server/mcp.js'
2. Import StdioServerTransport from '@modelcontextprotocol/sdk/server/stdio.js'
3. Import existing JMAPClient, loadConfig, createLogger

4. Create `createMCPServer()` function:
   - Takes config and logger as parameters
   - Creates McpServer with name: 'mcp-twake-mail', version: read from package.json or hardcode '0.1.0'
   - Returns { server, jmapClient } tuple

5. Create `startServer()` async function:
   - Load config via loadConfig()
   - Create logger via createLogger(config.LOG_LEVEL)
   - Create JMAPClient and call fetchSession() to validate connection
   - If fetchSession() throws, log error and process.exit(1)
   - Log "JMAP connection validated" on success
   - Create StdioServerTransport
   - Call server.connect(transport)
   - Log "MCP server running on stdio"

IMPORTANT:
- Never use console.log (stdout reserved for MCP JSON-RPC)
- Use pino logger to stderr only
- Handle errors gracefully with AI-friendly messages from JMAPError
  </action>
  <verify>
```bash
# Verify TypeScript compiles
npx tsc --noEmit

# Verify module exports
node -e "import('./dist/mcp/server.js').then(m => console.log(Object.keys(m)))"
```
  </verify>
  <done>
- src/mcp/server.ts exists with createMCPServer() and startServer() exports
- McpServer created with correct name/version
- StdioServerTransport used for stdio communication
- JMAP validation happens before server.connect()
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Entry Point</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to be the main entry point:

1. Import startServer from './mcp/server.js'
2. Call startServer() and catch any unhandled errors
3. On unhandled error: log to stderr and exit with code 1

The entry point should be minimal - just invoke startServer() with error boundary.

Example structure:
```typescript
import { startServer } from './mcp/server.js';

startServer().catch((error) => {
  // Log to stderr (not stdout!)
  process.stderr.write(`Fatal error: ${error instanceof Error ? error.message : String(error)}\n`);
  process.exit(1);
});
```
  </action>
  <verify>
```bash
# Build and verify entry point
npm run build

# Test startup (will fail without valid JMAP config, but should show correct error)
node dist/index.js 2>&1 | head -5
```
  </verify>
  <done>
- src/index.ts imports and calls startServer()
- Unhandled errors logged to stderr and exit with code 1
- No console.log or stdout writes
  </done>
</task>

</tasks>

<verification>
```bash
# Full build
npm run build

# TypeScript check
npx tsc --noEmit

# Verify MCP server structure (without running - needs env vars)
node -e "
import('./dist/mcp/server.js').then(m => {
  console.log('Exports:', Object.keys(m));
  console.log('createMCPServer:', typeof m.createMCPServer);
  console.log('startServer:', typeof m.startServer);
}).catch(e => console.error('Import failed:', e.message))
"
```
</verification>

<success_criteria>
- MCP server module exists at src/mcp/server.ts
- Server uses McpServer from @modelcontextprotocol/sdk
- Server uses StdioServerTransport for stdio communication
- JMAP connection validated via fetchSession() at startup
- Startup failures exit with code 1 and log to stderr
- Entry point at src/index.ts calls startServer()
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-read-operations/03-02-SUMMARY.md`
</output>
