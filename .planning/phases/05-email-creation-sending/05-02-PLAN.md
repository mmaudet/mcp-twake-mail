---
phase: 05-email-creation-sending
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/tools/email-sending.ts
autonomous: true

must_haves:
  truths:
    - "reply_email tool replies to existing email with proper threading"
    - "In-Reply-To header set to original email's messageId array"
    - "References header contains original's references plus original's messageId"
    - "Reply subject has 'Re:' prefix if not already present"
    - "Reply recipients derived from original's replyTo/from (and cc/to for replyAll)"
    - "Reply appears in same thread as original email"
  artifacts:
    - path: "src/mcp/tools/email-sending.ts"
      provides: "reply_email MCP tool"
      exports: ["registerEmailSendingTools"]
  key_links:
    - from: "src/mcp/tools/email-sending.ts"
      to: "src/jmap/client.ts"
      via: "Email/get to fetch original email threading info"
      pattern: "Email/get.*messageId.*references"
    - from: "reply_email"
      to: "Email object"
      via: "inReplyTo and references properties"
      pattern: "inReplyTo:.*references:"
---

<objective>
Implement reply_email MCP tool for replying to existing email threads

Purpose: Enable AI assistants to reply to emails with proper threading (In-Reply-To, References headers) so replies appear in the same conversation thread. This fulfills requirement EMAIL-02.

Output: Working reply_email tool that fetches original email's threading info, builds proper headers, and sends via the two-phase JMAP pattern.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-email-creation-sending/05-RESEARCH.md

# Code from previous plan (if executed first) or existing codebase
@src/mcp/tools/email-sending.ts
@src/types/jmap.ts
@src/jmap/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reply_email tool to email-sending.ts</name>
  <files>src/mcp/tools/email-sending.ts</files>
  <action>
Add reply_email tool to the existing registerEmailSendingTools function in src/mcp/tools/email-sending.ts:

**Input schema:**
- originalEmailId: z.string() - Required, ID of email being replied to
- body: z.string() - Required, plain text reply body
- htmlBody: z.string().optional() - Optional HTML reply body
- replyAll: z.boolean().default(false) - Include all recipients if true

**Implementation flow:**

1. **First request batch** (with SUBMISSION_USING) to gather all setup data:
   - Identity/get: { accountId }
   - Mailbox/query: { filter: { role: 'sent' } }
   - Mailbox/query: { filter: { role: 'drafts' } }
   - Email/get: { ids: [originalEmailId], properties: ['messageId', 'references', 'subject', 'from', 'to', 'cc', 'replyTo'] }

2. **Extract and validate:**
   - identity from Identity/get response (first identity)
   - sentMailboxId from Sent query (may be null)
   - draftsMailboxId from Drafts query (required)
   - original email from Email/get (required)
   - Throw helpful errors if identity or drafts missing, or original not found

3. **Build threading headers:**
   - inReplyTo: original.messageId || [] (MUST be array)
   - references: [...(original.references || []), ...(original.messageId || [])]
   - These are arrays of message-ID strings per RFC 8621

4. **Build subject:**
   - If original.subject starts with 'Re:' (case-insensitive check), use as-is
   - Otherwise prepend 'Re: '
   - Handle null/undefined subject gracefully

5. **Build recipients:**
   - Primary recipient: original.replyTo?.[0] || original.from?.[0]
   - toAddresses: [primaryRecipient]
   - ccAddresses: [] (initially empty)
   - If replyAll:
     - Add to toAddresses: all original.to except self (identity.email)
     - Add to ccAddresses: all original.cc except self
     - Use case-insensitive email comparison

6. **Build body structure** (same logic as send_email):
   - Both body and htmlBody: multipart/alternative
   - Only htmlBody: text/html
   - Only body: text/plain

7. **Build email object:**
   - mailboxIds: { [draftsMailboxId]: true }
   - from: [{ name: identity.name, email: identity.email }]
   - to: toAddresses
   - cc: ccAddresses (only if non-empty)
   - subject: computed subject with Re:
   - inReplyTo: computed array
   - references: computed array
   - bodyStructure and bodyValues

8. **Second request batch** (with SUBMISSION_USING):
   - Email/set create: { 'reply': emailObject }
   - EmailSubmission/set create: { 'submission': { identityId, emailId: '#reply' } }
   - onSuccessUpdateEmail: { '#submission': { 'keywords/$draft': null, mailbox transitions } }

9. **Handle responses:**
   - Check Email/set for notCreated.reply
   - Check EmailSubmission/set for notCreated.submission
   - Return { success: true, emailId, submissionId, threadId } on success

**Error messages:**
- Original not found: "Original email not found: {originalEmailId}"
- No identity: "No sending identity available. Contact your administrator."
- No drafts: "No Drafts mailbox found. Cannot send reply."
- Creation failed: Include error type and description

**Update log statement at end of registerEmailSendingTools:**
```typescript
logger.debug('Email sending tools registered: send_email, reply_email');
```
  </action>
  <verify>Run `npm run build` - no TypeScript errors</verify>
  <done>reply_email tool implemented with proper threading headers (inReplyTo, references) and recipient handling</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for email sending tools</name>
  <files>tests/unit/mcp/tools/email-sending.test.ts</files>
  <action>
Create tests/unit/mcp/tools/email-sending.test.ts with comprehensive tests:

**Test structure:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
// Mock the MCP SDK
vi.mock('@modelcontextprotocol/sdk/server/mcp.js', () => ({
  McpServer: vi.fn(),
}));

import { registerEmailSendingTools } from '../../../../src/mcp/tools/email-sending.js';
```

**Mock setup:**
- Create mock McpServer with registerTool that captures tool registrations
- Create mock JMAPClient with:
  - getSession() returning { accountId: 'account1' }
  - request() returning configurable responses
- Create mock logger with debug/error as vi.fn()

**Test cases for send_email:**

1. "registers send_email tool with correct metadata"
   - Verify registerTool called with 'send_email'
   - Verify inputSchema has to, cc, bcc, subject, body, htmlBody
   - Verify annotations have readOnlyHint: false, idempotentHint: false

2. "sends email with plain text body"
   - Mock successful Identity/get, Mailbox/query (sent, drafts), Email/set, EmailSubmission/set
   - Call handler with { to: ['test@example.com'], subject: 'Test', body: 'Hello' }
   - Verify Email/set called with bodyStructure type: 'text/plain'
   - Verify EmailSubmission/set called with identityId
   - Verify success response

3. "sends email with multipart body (text + HTML)"
   - Call with both body and htmlBody
   - Verify bodyStructure type: 'multipart/alternative'
   - Verify bodyValues has both 'text' and 'html' parts

4. "includes submission capability in requests"
   - Verify request() called with using array containing 'urn:ietf:params:jmap:submission'

5. "handles missing identity gracefully"
   - Mock Identity/get returning empty list
   - Verify error response about no identity

6. "handles email creation failure"
   - Mock Email/set with notCreated error
   - Verify error response includes error type

7. "handles submission failure"
   - Mock EmailSubmission/set with notCreated error
   - Verify error response includes error type

**Test cases for reply_email:**

8. "registers reply_email tool with correct metadata"
   - Verify registerTool called with 'reply_email'
   - Verify inputSchema has originalEmailId, body, htmlBody, replyAll

9. "builds correct threading headers"
   - Mock Email/get returning original with messageId: ['<msg1@ex.com>'], references: ['<ref1@ex.com>']
   - Call reply_email
   - Verify Email/set called with:
     - inReplyTo: ['<msg1@ex.com>']
     - references: ['<ref1@ex.com>', '<msg1@ex.com>']

10. "adds Re: prefix to subject"
    - Mock original with subject: 'Hello'
    - Verify reply has subject: 'Re: Hello'

11. "preserves existing Re: prefix"
    - Mock original with subject: 'Re: Hello'
    - Verify reply has subject: 'Re: Hello' (not 'Re: Re: Hello')

12. "uses replyTo address when available"
    - Mock original with replyTo: [{ email: 'reply@ex.com' }], from: [{ email: 'from@ex.com' }]
    - Verify to addresses include reply@ex.com, not from@ex.com

13. "falls back to from address when no replyTo"
    - Mock original with no replyTo, from: [{ email: 'from@ex.com' }]
    - Verify to addresses include from@ex.com

14. "includes all recipients on replyAll"
    - Mock original with to, cc containing multiple addresses
    - Mock identity with email 'me@ex.com'
    - Call with replyAll: true
    - Verify to includes original recipients except self
    - Verify cc includes original cc except self

15. "excludes self from replyAll recipients"
    - Mock original with to containing identity's email
    - Call with replyAll: true
    - Verify identity's email not in to or cc

16. "handles original email not found"
    - Mock Email/get returning empty list
    - Verify error: "Original email not found"
  </action>
  <verify>Run `npm test tests/unit/mcp/tools/email-sending.test.ts` - all tests pass</verify>
  <done>Unit tests covering send_email and reply_email tools, including threading, recipients, and error handling</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm test` - all tests pass including new email-sending tests
3. reply_email tool sets inReplyTo and references as arrays
4. reply_email adds Re: prefix correctly
5. reply_email handles replyAll recipient expansion
6. Both tools use submission capability
</verification>

<success_criteria>
1. reply_email tool added to email-sending.ts
2. Threading headers (inReplyTo, references) correctly built as arrays
3. Subject handling preserves or adds Re: prefix
4. Recipient logic handles replyTo fallback and replyAll expansion
5. Self-address excluded from replyAll recipients
6. Unit tests cover all major paths for both send_email and reply_email
7. All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-creation-sending/05-02-SUMMARY.md`
</output>
