---
phase: 02-authentication-system
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - package.json
  - src/auth/oidc-flow.ts
  - src/auth/index.ts
  - tests/auth/oidc-flow.test.ts
autonomous: true

must_haves:
  truths:
    - "User can initiate OIDC authentication flow via CLI"
    - "Browser opens to OIDC provider authorization page"
    - "Localhost callback captures authorization code"
    - "PKCE S256 code challenge is used (not plain)"
    - "Tokens are saved to token store after successful flow"
  artifacts:
    - path: "src/auth/oidc-flow.ts"
      provides: "OIDC authorization code flow with PKCE"
      exports: ["performOIDCFlow"]
    - path: "package.json"
      provides: "OIDC dependencies"
      contains: "openid-client"
  key_links:
    - from: "src/auth/oidc-flow.ts"
      to: "openid-client"
      via: "discovery and authorizationCodeGrant"
      pattern: "client\\.discovery|authorizationCodeGrant"
    - from: "src/auth/oidc-flow.ts"
      to: "src/auth/token-store.ts"
      via: "saveTokens after successful grant"
      pattern: "saveTokens"
    - from: "src/auth/oidc-flow.ts"
      to: "oauth-callback"
      via: "getAuthCode for localhost callback"
      pattern: "getAuthCode"
---

<objective>
Implement the OIDC authorization code flow with PKCE (S256) for user authentication against the OIDC provider.

Purpose: This is the primary authentication mechanism for OIDC users. When no valid token exists, users run this flow to authenticate with their OIDC provider (Lemonldap/Keycloak/etc.) and obtain access + refresh tokens.

Output: OIDC flow module that handles browser-based OAuth2 authorization with PKCE, captures the callback, exchanges code for tokens, and persists them.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-system/02-RESEARCH.md
@.planning/phases/02-authentication-system/02-01-SUMMARY.md

# Existing files (from 02-01)
@src/auth/token-store.ts
@src/config/schema.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install OIDC dependencies</name>
  <files>package.json</files>
  <action>
Install the required packages for OIDC authentication:

```bash
npm install openid-client oauth-callback open
```

Verify these versions are installed:
- openid-client ^6.8 (OpenID Certified, built-in PKCE)
- oauth-callback ^1.2 (localhost callback capture)
- open ^10.x (cross-platform browser launch)

These are production dependencies, not devDependencies.
  </action>
  <verify>
Run `npm ls openid-client oauth-callback open` - shows installed versions.
Run `npm run build` - no TypeScript errors from new imports.
  </verify>
  <done>
OIDC dependencies installed and available for import.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OIDC flow with PKCE</name>
  <files>src/auth/oidc-flow.ts, src/auth/index.ts, tests/auth/oidc-flow.test.ts</files>
  <action>
Create src/auth/oidc-flow.ts implementing the full OIDC authorization code flow with PKCE:

1. Import dependencies:
   ```typescript
   import * as client from 'openid-client';
   import { getAuthCode, OAuthError } from 'oauth-callback';
   import open from 'open';
   import type { Config } from '../config/schema.js';
   import { saveTokens, type StoredTokens } from './token-store.js';
   import { JMAPError } from '../errors.js';
   ```

2. Define OIDCFlowOptions interface:
   ```typescript
   interface OIDCFlowOptions {
     issuerUrl: string;
     clientId: string;
     scope: string;
     redirectPort: number;
   }
   ```

3. Implement performOIDCFlow(options: OIDCFlowOptions): Promise<StoredTokens>:

   a. OIDC Discovery:
      ```typescript
      const config = await client.discovery(
        new URL(options.issuerUrl),
        options.clientId
      );
      ```
      Wrap in try/catch, throw JMAPError.oidcFlowError('discovery', ...) on failure.

   b. Generate PKCE values:
      ```typescript
      const codeVerifier = client.randomPKCECodeVerifier();
      const codeChallenge = await client.calculatePKCECodeChallenge(codeVerifier);
      const state = client.randomState();
      ```

   c. Build redirect URI:
      ```typescript
      const redirectUri = `http://localhost:${options.redirectPort}/callback`;
      ```

   d. Build authorization URL:
      ```typescript
      const authUrl = client.buildAuthorizationUrl(config, {
        redirect_uri: redirectUri,
        scope: options.scope,
        code_challenge: codeChallenge,
        code_challenge_method: 'S256',  // CRITICAL: Always S256, never 'plain'
        state,
      });
      ```

   e. Launch browser and capture callback:
      ```typescript
      console.log('Opening browser for authentication...');
      console.log('If browser does not open, visit:', authUrl.href);

      const result = await getAuthCode({
        authorizationUrl: authUrl.href,
        port: options.redirectPort,
        callbackPath: '/callback',
        timeout: 120000,  // 2 minutes for user to complete
        launch: open,
      });
      ```
      Wrap in try/catch:
      - If OAuthError, throw JMAPError.oidcFlowError('callback', error.error_description)
      - If timeout/abort, throw JMAPError.oidcFlowError('callback', 'Authentication timed out')

   f. Validate state:
      ```typescript
      if (result.state !== state) {
        throw JMAPError.oidcFlowError('callback', 'State mismatch - possible CSRF attack');
      }
      ```

   g. Exchange code for tokens:
      ```typescript
      const tokens = await client.authorizationCodeGrant(config, {
        redirect_uri: redirectUri,
        code: result.code,
        pkceCodeVerifier: codeVerifier,
      });
      ```
      Wrap in try/catch, throw JMAPError.oidcFlowError('token_exchange', ...) on failure.

   h. Build and save StoredTokens:
      ```typescript
      const storedTokens: StoredTokens = {
        accessToken: tokens.access_token,
        refreshToken: tokens.refresh_token,
        expiresAt: tokens.expires_at,
        idToken: tokens.id_token,
      };

      await saveTokens(storedTokens);
      console.log('Authentication successful! Tokens saved.');

      return storedTokens;
      ```

4. Export helper to create options from config:
   ```typescript
   export function getOIDCOptionsFromConfig(config: Config): OIDCFlowOptions {
     if (config.JMAP_AUTH_METHOD !== 'oidc') {
       throw new Error('OIDC options only available when JMAP_AUTH_METHOD is oidc');
     }
     return {
       issuerUrl: config.JMAP_OIDC_ISSUER!,
       clientId: config.JMAP_OIDC_CLIENT_ID!,
       scope: config.JMAP_OIDC_SCOPE!,
       redirectPort: config.JMAP_OIDC_REDIRECT_PORT!,
     };
   }
   ```

5. Update src/auth/index.ts to export:
   ```typescript
   export * from './token-store.js';
   export * from './oidc-flow.js';
   ```

6. Create tests/auth/oidc-flow.test.ts:
   - Mock openid-client, oauth-callback, and open
   - Test successful flow (discovery -> auth URL -> callback -> token exchange -> save)
   - Test PKCE uses S256 (verify code_challenge_method in buildAuthorizationUrl call)
   - Test state validation failure
   - Test discovery failure throws oidcFlowError
   - Test callback error throws oidcFlowError
   - Test token exchange failure throws oidcFlowError
   - Test tokens are saved after successful exchange

CRITICAL: The code_challenge_method MUST be 'S256'. Never use 'plain' - this is a security requirement (AUTH-04).
  </action>
  <verify>
Run `npm run build` - no TypeScript errors.
Run `npm test -- tests/auth/oidc-flow.test.ts` - all OIDC flow tests pass.
Verify in test that code_challenge_method is 'S256' (not 'plain').
  </verify>
  <done>
OIDC flow implemented with PKCE S256. Browser-based auth launches, callback captured, tokens exchanged and saved.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   npm run build
   npm test
   ```
   All tests pass, no TypeScript errors.

2. Dependency verification:
   ```bash
   npm ls openid-client oauth-callback open
   ```
   All three packages installed at correct versions.

3. PKCE verification:
   - Test explicitly checks code_challenge_method is 'S256'
   - No 'plain' challenge method anywhere in code

4. Integration verification:
   - performOIDCFlow calls saveTokens with tokens
   - getOIDCOptionsFromConfig extracts config correctly
</verification>

<success_criteria>
- openid-client, oauth-callback, open packages installed
- performOIDCFlow implements full OIDC authorization code flow
- PKCE uses S256 code challenge method (never plain)
- Tokens are saved to token store after successful flow
- All tests pass with mocked external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-02-SUMMARY.md`
</output>
