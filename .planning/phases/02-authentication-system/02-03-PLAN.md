---
phase: 02-authentication-system
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/auth/token-refresh.ts
  - src/auth/index.ts
  - tests/auth/token-refresh.test.ts
autonomous: true

must_haves:
  truths:
    - "Access tokens auto-refresh before expiry without user intervention"
    - "Refresh uses 60-second buffer (refresh before actual expiry)"
    - "Concurrent refresh requests are serialized via mutex"
    - "Refresh failure throws error with re-authentication instructions"
    - "New refresh token is persisted if provided"
  artifacts:
    - path: "src/auth/token-refresh.ts"
      provides: "Token refresh logic with mutex"
      exports: ["ensureValidToken", "TokenRefresher"]
  key_links:
    - from: "src/auth/token-refresh.ts"
      to: "openid-client"
      via: "refreshTokenGrant"
      pattern: "refreshTokenGrant"
    - from: "src/auth/token-refresh.ts"
      to: "src/auth/token-store.ts"
      via: "loadTokens and saveTokens"
      pattern: "loadTokens|saveTokens"
---

<objective>
Implement automatic token refresh logic that silently renews access tokens before they expire, using a mutex to prevent race conditions during concurrent requests.

Purpose: When an MCP server handles multiple simultaneous requests, each may try to refresh the token if it's expiring soon. Without coordination, this causes "invalid_grant" errors. This module ensures only one refresh happens at a time and all callers get the fresh token.

Output: Token refresh module with expiry checking, automatic refresh via refresh_token grant, and mutex for concurrent access safety.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-system/02-RESEARCH.md
@.planning/phases/02-authentication-system/02-01-SUMMARY.md

# Existing files (from 02-01)
@src/auth/token-store.ts
@src/config/schema.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement token refresh with mutex</name>
  <files>src/auth/token-refresh.ts, src/auth/index.ts, tests/auth/token-refresh.test.ts</files>
  <action>
Create src/auth/token-refresh.ts implementing token refresh with concurrency safety:

1. Import dependencies:
   ```typescript
   import * as client from 'openid-client';
   import { loadTokens, saveTokens, type StoredTokens } from './token-store.js';
   import { JMAPError } from '../errors.js';
   ```

2. Define constants:
   ```typescript
   const TOKEN_EXPIRY_BUFFER = 60; // Refresh 60 seconds before actual expiry
   ```

3. Create TokenRefresher class with promise-based mutex:
   ```typescript
   export class TokenRefresher {
     private refreshPromise: Promise<StoredTokens> | null = null;
     private issuerConfig: client.Configuration | null = null;
     private readonly issuerUrl: string;
     private readonly clientId: string;

     constructor(issuerUrl: string, clientId: string) {
       this.issuerUrl = issuerUrl;
       this.clientId = clientId;
     }

     /**
      * Get or create OIDC issuer configuration (cached).
      */
     private async getIssuerConfig(): Promise<client.Configuration> {
       if (!this.issuerConfig) {
         this.issuerConfig = await client.discovery(
           new URL(this.issuerUrl),
           this.clientId
         );
       }
       return this.issuerConfig;
     }

     /**
      * Check if token is valid (not expired or expiring soon).
      */
     isTokenValid(tokens: StoredTokens): boolean {
       if (!tokens.expiresAt) {
         // No expiry info, assume valid (some servers don't return expires_at)
         return true;
       }
       const now = Math.floor(Date.now() / 1000);
       return tokens.expiresAt > now + TOKEN_EXPIRY_BUFFER;
     }

     /**
      * Ensure we have a valid token, refreshing if necessary.
      * Uses mutex to prevent concurrent refresh attempts.
      */
     async ensureValidToken(): Promise<StoredTokens> {
       // If a refresh is already in progress, wait for it
       if (this.refreshPromise) {
         return this.refreshPromise;
       }

       // Load current tokens
       const tokens = await loadTokens();
       if (!tokens) {
         throw JMAPError.noStoredTokens();
       }

       // Check if current token is still valid
       if (this.isTokenValid(tokens)) {
         return tokens;
       }

       // Token expired or expiring soon - need to refresh
       if (!tokens.refreshToken) {
         throw JMAPError.tokenExpired(false);
       }

       // Start refresh with mutex
       this.refreshPromise = this.doRefresh(tokens.refreshToken);

       try {
         const newTokens = await this.refreshPromise;
         return newTokens;
       } finally {
         // Clear mutex so next request can refresh if needed
         this.refreshPromise = null;
       }
     }

     /**
      * Perform the actual token refresh.
      */
     private async doRefresh(refreshToken: string): Promise<StoredTokens> {
       try {
         const config = await this.getIssuerConfig();
         const tokens = await client.refreshTokenGrant(config, refreshToken);

         const newTokens: StoredTokens = {
           accessToken: tokens.access_token,
           // Use new refresh token if provided, otherwise keep the old one
           refreshToken: tokens.refresh_token || refreshToken,
           expiresAt: tokens.expires_at,
           idToken: tokens.id_token,
         };

         await saveTokens(newTokens);
         return newTokens;
       } catch (error) {
         const message = error instanceof Error ? error.message : 'Unknown error';
         throw JMAPError.refreshFailed(message);
       }
     }

     /**
      * Clear cached issuer config (useful for testing or config changes).
      */
     clearCache(): void {
       this.issuerConfig = null;
     }
   }
   ```

4. Export factory function:
   ```typescript
   /**
    * Create a TokenRefresher instance from config.
    */
   export function createTokenRefresher(issuerUrl: string, clientId: string): TokenRefresher {
     return new TokenRefresher(issuerUrl, clientId);
   }
   ```

5. Update src/auth/index.ts to export:
   ```typescript
   export * from './token-store.js';
   export * from './token-refresh.js';
   // oidc-flow.js will be added by 02-02 plan
   ```

6. Create tests/auth/token-refresh.test.ts:
   - Mock openid-client (discovery, refreshTokenGrant)
   - Mock token-store (loadTokens, saveTokens)

   Test cases:
   a. Returns existing token if not expired
   b. Returns existing token if expiring in > 60 seconds
   c. Refreshes token if expiring in < 60 seconds
   d. Refreshes token if already expired
   e. Throws noStoredTokens if no tokens loaded
   f. Throws tokenExpired(false) if no refresh token available
   g. Throws refreshFailed with message on refresh error
   h. Saves new tokens after successful refresh
   i. Preserves old refresh token if new one not provided
   j. Mutex test: concurrent calls result in single refresh
      - Call ensureValidToken() 3 times simultaneously
      - Verify refreshTokenGrant only called once
      - All 3 calls receive the same refreshed tokens

IMPORTANT: The mutex pattern prevents the "invalid_grant" error that occurs when multiple concurrent refresh requests try to use the same refresh token (some OIDC providers invalidate refresh token after first use).
  </action>
  <verify>
Run `npm run build` - no TypeScript errors.
Run `npm test -- tests/auth/token-refresh.test.ts` - all refresh tests pass.
Verify mutex test shows single refresh call for concurrent requests.
  </verify>
  <done>
Token refresh implemented with 60-second buffer and mutex for concurrent safety. Tests verify single refresh under concurrent load.
  </done>
</task>

</tasks>

<verification>
After task completes:

1. Build verification:
   ```bash
   npm run build
   npm test
   ```
   All tests pass, no TypeScript errors.

2. Refresh logic verification:
   - Token valid: returns immediately, no refresh
   - Token expiring soon: triggers refresh
   - Token expired: triggers refresh
   - No refresh token: throws with re-auth message

3. Mutex verification:
   - Concurrent calls share single refresh
   - All callers receive refreshed tokens

4. Persistence verification:
   - New tokens saved after refresh
   - Old refresh token preserved if new not provided
</verification>

<success_criteria>
- TokenRefresher class with ensureValidToken() method
- 60-second expiry buffer (refresh before actual expiry)
- Promise-based mutex prevents concurrent refresh
- Refresh failures throw JMAPError.refreshFailed with message
- New tokens persisted after successful refresh
- All tests pass including concurrent access test
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-03-SUMMARY.md`
</output>
